import * as fs from 'fs-extra';
import * as path from 'path';
import { format } from 'date-fns';
import {
  TaskConfig,
  TaskOptions,
  TemplateVariables,
  TaskManagerError,
  FileSystemError
} from '../types';
import { I18n } from './i18n';

export class TaskFileManager {
  private taskFile: string;
  private archiveDir: string;
  private i18n: I18n;

  constructor(taskFile: string, archiveDir: string, i18n: I18n) {
    this.taskFile = taskFile;
    this.archiveDir = archiveDir;
    this.i18n = i18n;
  }

  async createTaskFile(
    title: string,
    description: string,
    options: TaskOptions,
    template: string,
    config: TaskConfig
  ): Promise<void> {
    const isJapanese = config.language === 'ja';

    const formatArrayToMarkdown = (items: string[] | string | undefined, defaultValue: string): string => {
      if (Array.isArray(items)) {
        if (items.length === 0) {
          return defaultValue;
        }
        const firstItem = items[0];
        const isComment = firstItem.startsWith('<!--') && firstItem.endsWith('-->');
        let result = isComment ? firstItem : `- ${firstItem}`;

        for (let i = 1; i < items.length; i++) {
          result += `\n- ${items[i]}`;
        }
        return result;
      }
      return items || defaultValue;
    };

    const defaultPrerequisites = isJapanese ? '<!-- 前提条件を記入してください -->' : '<!-- Add prerequisites here -->';
    const defaultRules = isJapanese ? '<!-- ルールを記入してください -->' : '<!-- Add rules here -->';
    const defaultTaskItems = isJapanese ? '- タスク 1\n- タスク 2\n- タスク 3' : '- Task 1\n- Task 2\n- Task 3';

    const variables: TemplateVariables = {
      TITLE: title,
      DESCRIPTION: description,
      DATE: new Date().toISOString(),
      TIMESTAMP: format(new Date(), 'yyyy-MM-dd HH:mm:ss'),
      PRIORITY: options.priority || 'medium',
      TAGS: options.tags?.join(', ') || '',
      PREREQUISITES: options.prerequisites || formatArrayToMarkdown(config.defaultPrerequisites, defaultPrerequisites),
      RULES: options.rules || formatArrayToMarkdown(config.defaultRules, defaultRules),
      TASKS: options.tasks || formatArrayToMarkdown(config.defaultTasks, defaultTaskItems)
    };

    let content = template;
    Object.entries(variables).forEach(([key, value]) => {
      content = content.replace(new RegExp(`{{${key}}}`, 'g'), value);
    });

    await fs.writeFile(this.taskFile, content);
  }

  async archiveCurrentTask(): Promise<string | null> {
    try {
      if (!await fs.pathExists(this.taskFile)) {
        return null;
      }

      const now = new Date();
      const timestamp = format(now, 'yyyy-MM-dd_HH-mm-ss');
      const milliseconds = now.getMilliseconds().toString().padStart(3, '0');
      const archiveFileName = `${timestamp}-${milliseconds}_task.md`;
      const archivePath = path.join(this.archiveDir, archiveFileName);

      const currentContent = await fs.readFile(this.taskFile, 'utf8');
      const archivedContent = `<!-- Archived: ${new Date().toISOString()} -->\n\n${currentContent}`;

      await fs.writeFile(archivePath, archivedContent);
      await fs.remove(this.taskFile);

      return archivePath;
    } catch (error) {
      throw new FileSystemError(
        `Failed to archive current task: ${error instanceof Error ? error.message : 'Unknown error'}`,
        this.taskFile,
        'archive'
      );
    }
  }

  async getTaskContent(): Promise<string> {
    if (!await fs.pathExists(this.taskFile)) {
      throw new TaskManagerError(this.i18n.t('errors.noTaskFile'), 'NO_TASK_FILE');
    }
    return await fs.readFile(this.taskFile, 'utf8');
  }

  async taskFileExists(): Promise<boolean> {
    return await fs.pathExists(this.taskFile);
  }

  async appendToTaskFile(content: string): Promise<void> {
    await fs.appendFile(this.taskFile, content);
  }

  getTaskFilePath(): string {
    return this.taskFile;
  }

  getDefaultTaskTemplate(): string {
    try {
      const t = this.i18n.getNamespace('taskTemplate');
      if (!t || !t.title) {
        throw new Error('i18n taskTemplate namespace not loaded');
      }
      return `${t.title}

${t.created}
${t.priority}
${t.tags}

${t.description}

${t.prerequisites}

${t.rules}

${t.tasks}

${t.context}

${t.notes}

${t.footer}
`;
    } catch {
      return `# {{TITLE}}

**Created:** {{DATE}}
**Priority:** {{PRIORITY}}
**Tags:** {{TAGS}}

## Description
{{DESCRIPTION}}

## Prerequisites
{{PREREQUISITES}}

## Rules
{{RULES}}

## Tasks
{{TASKS}}

## Context
<!-- Add context for Claude Code execution -->

## Notes
<!-- Add your notes here -->

---
*Generated by Claude Task Manager*`;
    }
  }

  async getTaskTemplate(config: TaskConfig): Promise<string> {
    return config.taskTemplate || this.getDefaultTaskTemplate();
  }
}
